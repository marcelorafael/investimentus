"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
exports.stripExtension = exports.getRelativePath = exports.formatPath = void 0;
var path_1 = __importDefault(require("path"));
/**
 * Determines if the path is prefixed or not
 *
 * @param {String} relativePath - Relative path to check for directory prefixes
 * @returns True if path prefix exists, otherwise false
 */
var hasPathPrefix = function (relativePath) {
    return relativePath.substr(0, 2) === '..' ||
        relativePath.substr(0, 2) === './' ||
        relativePath.substr(0, 2) === '.\\';
};
/**
 * Correctly formats path separators
 *
 * @param {String} path - Path to format
 * @returns Path with the correct separators
 */
exports.formatPath = function (dir, separator) {
    if (separator === void 0) { separator = '/'; }
    var oppositeSep = separator === '/' ? '\\' : '/';
    return dir.replace(new RegExp("\\" + oppositeSep, 'g'), separator);
};
/**
 * Converts a path into a relative path
 *
 * @param {String} file - File to convert to a relative path
 * @param {String} fromDir - Directory to resolve to
 */
exports.getRelativePath = function (file, fromDir) {
    // format paths to the OS specific format
    // (accounting for using the wrong seps)
    var relativePath = path_1["default"].relative(exports.formatPath(fromDir, path_1["default"].sep), exports.formatPath(file, path_1["default"].sep));
    // Prefix the path if it is not already prefixed
    if (!hasPathPrefix(relativePath)) {
        relativePath = "./" + relativePath;
    }
    return exports.formatPath(relativePath);
};
exports.stripExtension = function (file) {
    var ext = path_1["default"].extname(file);
    var result = file.slice(0, file.length - ext.length);
    return result;
};
//# sourceMappingURL=paths.js.map