"use strict";

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.function.bind");

require("core-js/modules/es.object.assign");

require("core-js/modules/es.object.create");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.get-prototype-of");

require("core-js/modules/es.object.set-prototype-of");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.string.iterator");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TriangleColorPicker = void 0;

var _react = _interopRequireDefault(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _reactNative = require("react-native");

var _tinycolor = _interopRequireDefault(require("tinycolor2"));

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function makeRotationKey(props, angle) {
  var rotationHackFactor = props.rotationHackFactor;

  if (rotationHackFactor < 1) {
    return undefined;
  }

  var key = Math.floor(angle * rotationHackFactor);
  return "r".concat(key);
}

var TriangleColorPicker =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(TriangleColorPicker, _React$PureComponent);

  function TriangleColorPicker(props, ctx) {
    var _this;

    _classCallCheck(this, TriangleColorPicker);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(TriangleColorPicker).call(this, props, ctx));

    _this._handleColorChange = function (_ref) {
      var x = _ref.x,
          y = _ref.y;

      if (_this._changingHColor) {
        _this._handleHColorChange({
          x: x,
          y: y
        });
      } else {
        _this._handleSVColorChange({
          x: x,
          y: y
        });
      }
    };

    var state = {
      color: {
        h: 0,
        s: 1,
        v: 1
      },
      pickerSize: null
    };

    if (props.oldColor) {
      state.color = (0, _tinycolor["default"])(props.oldColor).toHsv();
    }

    if (props.defaultColor) {
      state.color = (0, _tinycolor["default"])(props.defaultColor).toHsv();
    }

    _this.state = state;
    _this._layout = {
      width: 0,
      height: 0,
      x: 0,
      y: 0
    };
    _this._pageX = 0;
    _this._pageY = 0;
    _this._onLayout = _this._onLayout.bind(_assertThisInitialized(_this));
    _this._onSValueChange = _this._onSValueChange.bind(_assertThisInitialized(_this));
    _this._onVValueChange = _this._onVValueChange.bind(_assertThisInitialized(_this));
    _this._onColorSelected = _this._onColorSelected.bind(_assertThisInitialized(_this));
    _this._onOldColorSelected = _this._onOldColorSelected.bind(_assertThisInitialized(_this));
    _this._isRTL = _reactNative.I18nManager.isRTL;
    _this._pickerResponder = (0, _utils.createPanResponder)({
      onStart: function onStart(_ref2) {
        var x = _ref2.x,
            y = _ref2.y;

        var _this$_computeColorFr = _this._computeColorFromTriangle({
          x: x,
          y: y
        }),
            s = _this$_computeColorFr.s,
            v = _this$_computeColorFr.v;

        _this._changingHColor = s > 1 || s < 0 || v > 1 || v < 0;

        _this._handleColorChange({
          x: x,
          y: y
        });
      },
      onMove: _this._handleColorChange
    });
    _this.pickerContainer = _react["default"].createRef();
    return _this;
  }

  _createClass(TriangleColorPicker, [{
    key: "getColor",
    value: function getColor() {
      return (0, _tinycolor["default"])(this._getColor()).toHexString();
    }
  }, {
    key: "_getColor",
    value: function _getColor() {
      var passedColor = typeof this.props.color === 'string' ? (0, _tinycolor["default"])(this.props.color).toHsv() : this.props.color;
      return passedColor || this.state.color;
    }
  }, {
    key: "_onColorSelected",
    value: function _onColorSelected() {
      var onColorSelected = this.props.onColorSelected;
      var color = (0, _tinycolor["default"])(this._getColor()).toHexString();
      if (onColorSelected) onColorSelected(color);
    }
  }, {
    key: "_onOldColorSelected",
    value: function _onOldColorSelected() {
      var _this$props = this.props,
          oldColor = _this$props.oldColor,
          onOldColorSelected = _this$props.onOldColorSelected;
      var color = (0, _tinycolor["default"])(oldColor);
      this.setState({
        color: color.toHsv()
      });
      if (onOldColorSelected) onOldColorSelected(color.toHexString());
    }
  }, {
    key: "_onSValueChange",
    value: function _onSValueChange(s) {
      var _this$_getColor = this._getColor(),
          h = _this$_getColor.h,
          v = _this$_getColor.v;

      this._onColorChange({
        h: h,
        s: s,
        v: v
      });
    }
  }, {
    key: "_onVValueChange",
    value: function _onVValueChange(v) {
      var _this$_getColor2 = this._getColor(),
          h = _this$_getColor2.h,
          s = _this$_getColor2.s;

      this._onColorChange({
        h: h,
        s: s,
        v: v
      });
    }
  }, {
    key: "_onColorChange",
    value: function _onColorChange(color) {
      this.setState({
        color: color
      });

      if (this.props.onColorChange) {
        this.props.onColorChange(color);
      }
    }
  }, {
    key: "_onLayout",
    value: function _onLayout(l) {
      var _this2 = this;

      this._layout = l.nativeEvent.layout;
      var _this$_layout = this._layout,
          width = _this$_layout.width,
          height = _this$_layout.height;
      var pickerSize = Math.min(width, height);

      if (this.state.pickerSize !== pickerSize) {
        this.setState({
          pickerSize: pickerSize
        });
      } // layout.x, layout.y is always 0
      // we always measure because layout is the same even though picker is moved on the page


      _reactNative.InteractionManager.runAfterInteractions(function () {
        // measure only after (possible) animation ended
        if (_this2.pickerContainer.current) {
          _this2.pickerContainer.current.measure(function (_x, _y, _width, _height, pageX, pageY) {
            // picker position in the screen
            _this2._pageX = pageX;
            _this2._pageY = pageY;
          });
        }
      });
    }
  }, {
    key: "_computeHValue",
    value: function _computeHValue(x, y) {
      var mx = this.state.pickerSize / 2;
      var my = this.state.pickerSize / 2;
      var dx = x - mx;
      var dy = y - my;
      var rad = Math.atan2(dx, dy) + Math.PI + Math.PI / 2;
      return rad * 180 / Math.PI % 360;
    }
  }, {
    key: "_hValueToRad",
    value: function _hValueToRad(deg) {
      var rad = deg * Math.PI / 180;
      return rad - Math.PI - Math.PI / 2;
    }
  }, {
    key: "_handleHColorChange",
    value: function _handleHColorChange(_ref3) {
      var x = _ref3.x,
          y = _ref3.y;

      var _this$_getColor3 = this._getColor(),
          s = _this$_getColor3.s,
          v = _this$_getColor3.v;

      var marginLeft = (this._layout.width - this.state.pickerSize) / 2;
      var marginTop = (this._layout.height - this.state.pickerSize) / 2;
      var relativeX = x - this._pageX - marginLeft;
      var relativeY = y - this._pageY - marginTop;

      var h = this._computeHValue(relativeX, relativeY);

      this._onColorChange({
        h: h,
        s: s,
        v: v
      });
    }
  }, {
    key: "_handleSVColorChange",
    value: function _handleSVColorChange(_ref4) {
      var x = _ref4.x,
          y = _ref4.y;

      var _this$_computeColorFr2 = this._computeColorFromTriangle({
        x: x,
        y: y
      }),
          h = _this$_computeColorFr2.h,
          rawS = _this$_computeColorFr2.s,
          rawV = _this$_computeColorFr2.v;

      var s = Math.min(Math.max(0, rawS), 1);
      var v = Math.min(Math.max(0, rawV), 1);

      this._onColorChange({
        h: h,
        s: s,
        v: v
      });
    }
  }, {
    key: "_normalizeTriangleTouch",
    value: function _normalizeTriangleTouch(s, v, sRatio) {
      var CORNER_ZONE_SIZE = 0.12; // relative size to be considered as corner zone

      var NORMAL_MARGIN = 0.1; // relative triangle margin to be considered as touch in triangle

      var CORNER_MARGIN = 0.05; // relative triangle margin to be considered as touch in triangle in corner zone

      var margin = NORMAL_MARGIN;
      var posNS = v > 0 ? 1 - (1 - s) * sRatio : 1 - s * sRatio;
      var negNS = v > 0 ? s * sRatio : (1 - s) * sRatio;
      var ns = s > 1 ? posNS : negNS; // normalized s value according to ratio and s value

      var rightCorner = s > 1 - CORNER_ZONE_SIZE && v > 1 - CORNER_ZONE_SIZE;
      var leftCorner = ns < 0 + CORNER_ZONE_SIZE && v > 1 - CORNER_ZONE_SIZE;
      var topCorner = ns < 0 + CORNER_ZONE_SIZE && v < 0 + CORNER_ZONE_SIZE;

      if (rightCorner) {
        return {
          s: s,
          v: v
        };
      }

      if (leftCorner || topCorner) {
        margin = CORNER_MARGIN;
      }

      var s1 = s;
      var v1 = v; // color normalization according to margin

      s1 = s1 < 0 && ns > 0 - margin ? 0 : s1;
      s1 = s1 > 1 && ns < 1 + margin ? 1 : s1;
      v1 = v1 < 0 && v1 > 0 - margin ? 0 : v1;
      v1 = v1 > 1 && v1 < 1 + margin ? 1 : v1;
      return {
        s1: s1,
        v1: v1
      };
    }
    /**
     * Computes s, v from position (x, y). If position is outside of triangle,
     * it will return invalid values (greater than 1 or lower than 0)
     */

  }, {
    key: "_computeColorFromTriangle",
    value: function _computeColorFromTriangle(_ref5) {
      var x = _ref5.x,
          y = _ref5.y;
      var pickerSize = this.state.pickerSize;

      var _getPickerProperties = getPickerProperties(pickerSize),
          triangleHeight = _getPickerProperties.triangleHeight,
          triangleWidth = _getPickerProperties.triangleWidth;

      var left = pickerSize / 2 - triangleWidth / 2;
      var top = pickerSize / 2 - 2 * triangleHeight / 3; // triangle relative coordinates

      var marginLeft = (this._layout.width - this.state.pickerSize) / 2;
      var marginTop = (this._layout.height - this.state.pickerSize) / 2;
      var relativeX = x - this._pageX - marginLeft - left;
      var relativeY = y - this._pageY - marginTop - top; // rotation

      var _this$_getColor4 = this._getColor(),
          h = _this$_getColor4.h;

      var deg = (h - 330 + 360) % 360; // starting angle is 330 due to comfortable calculation

      var rad = deg * Math.PI / 180;
      var center = {
        x: triangleWidth / 2,
        y: 2 * triangleHeight / 3
      };
      var rotated = (0, _utils.rotatePoint)({
        x: relativeX,
        y: relativeY
      }, rad, center);
      var line = triangleWidth * rotated.y / triangleHeight;
      var margin = triangleWidth / 2 - triangleWidth / 2 * rotated.y / triangleHeight;
      var s = (rotated.x - margin) / line;
      var v = rotated.y / triangleHeight; // normalize

      var normalized = this._normalizeTriangleTouch(s, v, line / triangleHeight);

      return {
        h: h,
        s: normalized.s,
        v: normalized.v
      };
    }
  }, {
    key: "render",
    value: function render() {
      var pickerSize = this.state.pickerSize;
      var _this$props2 = this.props,
          oldColor = _this$props2.oldColor,
          style = _this$props2.style;

      var color = this._getColor();

      var h = color.h;

      var angle = this._hValueToRad(h);

      var selectedColor = (0, _tinycolor["default"])(color).toHexString();
      var indicatorColor = (0, _tinycolor["default"])({
        h: h,
        s: 1,
        v: 1
      }).toHexString();
      var computed = makeComputedStyles({
        pickerSize: pickerSize,
        selectedColor: selectedColor,
        selectedColorHsv: color,
        indicatorColor: indicatorColor,
        oldColor: oldColor,
        angle: angle,
        isRTL: this._isRTL
      }); // Hack for https://github.com/instea/react-native-color-picker/issues/17

      var rotationHack = makeRotationKey(this.props, angle);
      return _react["default"].createElement(_reactNative.View, {
        style: style
      }, _react["default"].createElement(_reactNative.View, {
        onLayout: this._onLayout,
        ref: this.pickerContainer,
        style: styles.pickerContainer
      }, !pickerSize ? null : _react["default"].createElement(_reactNative.View, null, _react["default"].createElement(_reactNative.View, {
        key: rotationHack,
        style: [styles.triangleContainer, computed.triangleContainer]
      }, _react["default"].createElement(_reactNative.View, {
        style: [styles.triangleUnderlayingColor, computed.triangleUnderlayingColor]
      }), _react["default"].createElement(_reactNative.Image, {
        style: [styles.triangleImage, computed.triangleImage],
        source: require('./resources/hsv_triangle_mask.png')
      })), _react["default"].createElement(_reactNative.View, _extends({}, this._pickerResponder.panHandlers, {
        style: [styles.picker, computed.picker],
        collapsable: false
      }), _react["default"].createElement(_reactNative.Image, {
        source: require('./resources/color-circle.png'),
        resizeMode: "contain",
        style: [styles.pickerImage]
      }), _react["default"].createElement(_reactNative.View, {
        key: rotationHack,
        style: [styles.pickerIndicator, computed.pickerIndicator]
      }, _react["default"].createElement(_reactNative.View, {
        style: [styles.pickerIndicatorTick, computed.pickerIndicatorTick]
      })), _react["default"].createElement(_reactNative.View, {
        style: [styles.svIndicator, computed.svIndicator]
      })))), _react["default"].createElement(_reactNative.View, {
        style: [styles.colorPreviews, computed.colorPreviews]
      }, oldColor && _react["default"].createElement(_reactNative.TouchableOpacity, {
        style: [styles.colorPreview, {
          backgroundColor: oldColor
        }],
        onPress: this._onOldColorSelected,
        activeOpacity: 0.7
      }), _react["default"].createElement(_reactNative.TouchableOpacity, {
        style: [styles.colorPreview, {
          backgroundColor: selectedColor
        }],
        onPress: this._onColorSelected,
        activeOpacity: 0.7
      })));
    }
  }]);

  return TriangleColorPicker;
}(_react["default"].PureComponent);

exports.TriangleColorPicker = TriangleColorPicker;
TriangleColorPicker.propTypes = {
  color: _propTypes["default"].oneOfType([_propTypes["default"].string, _propTypes["default"].shape({
    h: _propTypes["default"].number,
    s: _propTypes["default"].number,
    v: _propTypes["default"].number
  })]),
  defaultColor: _propTypes["default"].string,
  oldColor: _propTypes["default"].string,
  onColorChange: _propTypes["default"].func,
  onColorSelected: _propTypes["default"].func,
  onOldColorSelected: _propTypes["default"].func,
  rotationHackFactor: _propTypes["default"].number,
  style: {}
};
TriangleColorPicker.defaultProps = {
  rotationHackFactor: 100
};

function getPickerProperties(pickerSize) {
  var indicatorPickerRatio = 42 / 510; // computed from picker image

  var originalIndicatorSize = indicatorPickerRatio * pickerSize;
  var indicatorSize = originalIndicatorSize;
  var pickerPadding = originalIndicatorSize / 3;
  var triangleSize = pickerSize - 6 * pickerPadding;
  var triangleRadius = triangleSize / 2;
  var triangleHeight = triangleRadius * 3 / 2;
  var triangleWidth = 2 * triangleRadius * Math.sqrt(3 / 4); // pythagorean theorem

  return {
    triangleSize: triangleSize,
    triangleRadius: triangleRadius,
    triangleHeight: triangleHeight,
    triangleWidth: triangleWidth,
    indicatorPickerRatio: indicatorPickerRatio,
    indicatorSize: indicatorSize,
    pickerPadding: pickerPadding
  };
}

var makeComputedStyles = function makeComputedStyles(_ref6) {
  var _pickerIndicator, _svIndicator;

  var indicatorColor = _ref6.indicatorColor,
      angle = _ref6.angle,
      pickerSize = _ref6.pickerSize,
      selectedColorHsv = _ref6.selectedColorHsv,
      isRTL = _ref6.isRTL;

  var _getPickerProperties2 = getPickerProperties(pickerSize),
      triangleSize = _getPickerProperties2.triangleSize,
      triangleHeight = _getPickerProperties2.triangleHeight,
      triangleWidth = _getPickerProperties2.triangleWidth,
      indicatorSize = _getPickerProperties2.indicatorSize,
      pickerPadding = _getPickerProperties2.pickerPadding;
  /* ===== INDICATOR ===== */


  var indicatorRadius = pickerSize / 2 - indicatorSize / 2 - pickerPadding;
  var mx = pickerSize / 2;
  var my = pickerSize / 2;
  var dx = Math.cos(angle) * indicatorRadius;
  var dy = Math.sin(angle) * indicatorRadius;
  /* ===== TRIANGLE ===== */

  var triangleTop = pickerPadding * 3;
  var triangleLeft = pickerPadding * 3;
  var triangleAngle = -angle + Math.PI / 3;
  /* ===== SV INDICATOR ===== */

  var markerColor = 'rgba(0,0,0,0.8)';
  var s = selectedColorHsv.s,
      v = selectedColorHsv.v,
      h = selectedColorHsv.h;
  var svIndicatorSize = 18;
  var svY = v * triangleHeight;
  var margin = triangleWidth / 2 - v * (triangleWidth / 2);
  var svX = s * (triangleWidth - 2 * margin) + margin;
  var svIndicatorMarginLeft = (pickerSize - triangleWidth) / 2;
  var svIndicatorMarginTop = (pickerSize - 4 * triangleHeight / 3) / 2;
  var deg = (h - 330 + 360) % 360; // starting angle is 330 due to comfortable calculation

  var rad = deg * Math.PI / 180;
  var center = {
    x: pickerSize / 2,
    y: pickerSize / 2
  };
  var notRotatedPoint = {
    x: svIndicatorMarginTop + svY,
    y: svIndicatorMarginLeft + svX
  };
  var svIndicatorPoint = (0, _utils.rotatePoint)(notRotatedPoint, rad, center);
  return {
    picker: {
      padding: pickerPadding,
      width: pickerSize,
      height: pickerSize
    },
    pickerIndicator: (_pickerIndicator = {
      top: mx + dx - indicatorSize / 2
    }, _defineProperty(_pickerIndicator, isRTL ? 'right' : 'left', my + dy - indicatorSize / 2), _defineProperty(_pickerIndicator, "width", indicatorSize), _defineProperty(_pickerIndicator, "height", indicatorSize), _defineProperty(_pickerIndicator, "transform", [{
      rotate: "".concat(-angle, "rad")
    }]), _pickerIndicator),
    pickerIndicatorTick: {
      height: indicatorSize / 2,
      backgroundColor: markerColor
    },
    svIndicator: (_svIndicator = {
      top: svIndicatorPoint.x - svIndicatorSize / 2
    }, _defineProperty(_svIndicator, isRTL ? 'right' : 'left', svIndicatorPoint.y - svIndicatorSize / 2), _defineProperty(_svIndicator, "width", svIndicatorSize), _defineProperty(_svIndicator, "height", svIndicatorSize), _defineProperty(_svIndicator, "borderRadius", svIndicatorSize / 2), _defineProperty(_svIndicator, "borderColor", markerColor), _svIndicator),
    triangleContainer: {
      width: triangleSize,
      height: triangleSize,
      transform: [{
        rotate: "".concat(triangleAngle, "rad")
      }],
      top: triangleTop,
      left: triangleLeft
    },
    triangleImage: {
      width: triangleWidth,
      height: triangleHeight
    },
    triangleUnderlayingColor: {
      left: (triangleSize - triangleWidth) / 2,
      borderLeftWidth: triangleWidth / 2,
      borderRightWidth: triangleWidth / 2,
      borderBottomWidth: triangleHeight,
      borderBottomColor: indicatorColor
    },
    colorPreviews: {
      height: pickerSize * 0.1 // responsive height

    }
  };
};

var styles = _reactNative.StyleSheet.create({
  pickerContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center'
  },
  pickerImage: {
    flex: 1,
    width: null,
    height: null
  },
  pickerIndicator: {
    position: 'absolute',
    alignItems: 'center',
    justifyContent: 'center'
  },
  triangleContainer: {
    position: 'absolute',
    alignItems: 'center'
  },
  triangleUnderlayingColor: {
    position: 'absolute',
    top: 0,
    width: 0,
    height: 0,
    backgroundColor: 'transparent',
    borderStyle: 'solid',
    borderLeftColor: 'transparent',
    borderRightColor: 'transparent'
  },
  pickerAlignment: {
    alignItems: 'center'
  },
  svIndicator: {
    position: 'absolute',
    borderWidth: 4
  },
  pickerIndicatorTick: {
    width: 5
  },
  colorPreviews: {
    flexDirection: 'row'
  },
  colorPreview: {
    flex: 1
  }
});