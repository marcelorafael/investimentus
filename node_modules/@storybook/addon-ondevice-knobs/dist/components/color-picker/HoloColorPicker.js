"use strict";

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.symbol.iterator");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.function.bind");

require("core-js/modules/es.object.assign");

require("core-js/modules/es.object.create");

require("core-js/modules/es.object.define-property");

require("core-js/modules/es.object.get-prototype-of");

require("core-js/modules/es.object.set-prototype-of");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.string.iterator");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HoloColorPicker = void 0;

var _react = _interopRequireDefault(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _reactNative = require("react-native");

var _tinycolor = _interopRequireDefault(require("tinycolor2"));

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

// TODO: Raise PR at react-native-color-picker with these fixes
var HoloColorPicker =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(HoloColorPicker, _React$PureComponent);

  function HoloColorPicker(props, ctx) {
    var _this;

    _classCallCheck(this, HoloColorPicker);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(HoloColorPicker).call(this, props, ctx));

    _this._handleColorChange = function (_ref) {
      var x = _ref.x,
          y = _ref.y;

      var _this$_getColor = _this._getColor(),
          s = _this$_getColor.s,
          v = _this$_getColor.v;

      var marginLeft = (_this._layout.width - _this.state.pickerSize) / 2;
      var marginTop = (_this._layout.height - _this.state.pickerSize) / 2;
      var relativeX = x - _this._pageX - marginLeft;
      var relativeY = y - _this._pageY - marginTop;

      var h = _this._computeHValue(relativeX, relativeY);

      _this._onColorChange({
        h: h,
        s: s,
        v: v
      });
    };

    var state = {
      color: {
        h: 0,
        s: 1,
        v: 1
      },
      pickerSize: null
    };

    if (props.oldColor) {
      state.color = (0, _tinycolor["default"])(props.oldColor).toHsv();
    }

    if (props.defaultColor) {
      state.color = (0, _tinycolor["default"])(props.defaultColor).toHsv();
    }

    _this.state = state;
    _this._layout = {
      width: 0,
      height: 0,
      x: 0,
      y: 0
    };
    _this._pageX = 0;
    _this._pageY = 0;
    _this._onLayout = _this._onLayout.bind(_assertThisInitialized(_this));
    _this._onSValueChange = _this._onSValueChange.bind(_assertThisInitialized(_this));
    _this._onVValueChange = _this._onVValueChange.bind(_assertThisInitialized(_this));
    _this._onColorSelected = _this._onColorSelected.bind(_assertThisInitialized(_this));
    _this._onOldColorSelected = _this._onOldColorSelected.bind(_assertThisInitialized(_this));
    _this._isRTL = _reactNative.I18nManager.isRTL;
    _this._pickerResponder = (0, _utils.createPanResponder)({
      onStart: _this._handleColorChange,
      onMove: _this._handleColorChange
    });
    _this.pickerContainer = _react["default"].createRef();
    return _this;
  }

  _createClass(HoloColorPicker, [{
    key: "getColor",
    value: function getColor() {
      return (0, _tinycolor["default"])(this._getColor()).toHexString();
    }
  }, {
    key: "_onSValueChange",
    value: function _onSValueChange(s) {
      var _this$_getColor2 = this._getColor(),
          h = _this$_getColor2.h,
          v = _this$_getColor2.v;

      this._onColorChange({
        h: h,
        s: s,
        v: v
      });
    }
  }, {
    key: "_onVValueChange",
    value: function _onVValueChange(v) {
      var _this$_getColor3 = this._getColor(),
          h = _this$_getColor3.h,
          s = _this$_getColor3.s;

      this._onColorChange({
        h: h,
        s: s,
        v: v
      });
    }
  }, {
    key: "_onColorChange",
    value: function _onColorChange(color) {
      this.setState({
        color: color
      });

      if (this.props.onColorChange) {
        this.props.onColorChange(color);
      }
    }
  }, {
    key: "_onLayout",
    value: function _onLayout(l) {
      var _this2 = this;

      this._layout = l.nativeEvent.layout;
      var _this$_layout = this._layout,
          width = _this$_layout.width,
          height = _this$_layout.height;
      var pickerSize = Math.min(width, height);

      if (this.state.pickerSize !== pickerSize) {
        this.setState({
          pickerSize: pickerSize
        });
      } // layout.x, layout.y is always 0
      // we always measure because layout is the same even though picker is moved on the page


      _reactNative.InteractionManager.runAfterInteractions(function () {
        return (// measure only after (possible) animation ended
          _this2.pickerContainer.current && _this2.pickerContainer.current.measure(function (_x, _y, _width, _height, pageX, pageY) {
            // picker position in the screen
            _this2._pageX = pageX;
            _this2._pageY = pageY;
          })
        );
      });
    }
  }, {
    key: "_getColor",
    value: function _getColor() {
      var passedColor = typeof this.props.color === 'string' ? (0, _tinycolor["default"])(this.props.color).toHsv() : this.props.color;
      return passedColor || this.state.color;
    }
  }, {
    key: "_onColorSelected",
    value: function _onColorSelected() {
      var onColorSelected = this.props.onColorSelected;
      var color = (0, _tinycolor["default"])(this._getColor()).toHexString();
      if (onColorSelected) onColorSelected(color);
    }
  }, {
    key: "_onOldColorSelected",
    value: function _onOldColorSelected() {
      var _this$props = this.props,
          oldColor = _this$props.oldColor,
          onOldColorSelected = _this$props.onOldColorSelected;
      var color = (0, _tinycolor["default"])(oldColor);
      this.setState({
        color: color.toHsv()
      });
      if (onOldColorSelected) onOldColorSelected(color.toHexString());
    }
  }, {
    key: "_computeHValue",
    value: function _computeHValue(x, y) {
      var mx = this.state.pickerSize / 2;
      var my = this.state.pickerSize / 2;
      var dx = x - mx;
      var dy = y - my;
      var rad = Math.atan2(dx, dy) + Math.PI + Math.PI / 2;
      return rad * 180 / Math.PI % 360;
    }
  }, {
    key: "_hValueToRad",
    value: function _hValueToRad(deg) {
      var rad = deg * Math.PI / 180;
      return rad - Math.PI - Math.PI / 2;
    }
  }, {
    key: "_getSlider",
    value: function _getSlider() {
      if (this.props.hideSliders) {
        return undefined;
      }

      if (this.props.sliderComponent) {
        return this.props.sliderComponent;
      }

      if (!_reactNative.Slider) {
        throw new Error('You need to install `@react-native-community/slider` and pass it (or any other Slider compatible component) as `sliderComponent` prop');
      }

      return _reactNative.Slider;
    }
  }, {
    key: "render",
    value: function render() {
      var pickerSize = this.state.pickerSize;
      var _this$props2 = this.props,
          oldColor = _this$props2.oldColor,
          style = _this$props2.style;

      var color = this._getColor();

      var h = color.h,
          s = color.s,
          v = color.v;

      var angle = this._hValueToRad(h);

      var selectedColor = (0, _tinycolor["default"])(color).toHexString();
      var indicatorColor = (0, _tinycolor["default"])({
        h: h,
        s: 1,
        v: 1
      }).toHexString();
      var computed = makeComputedStyles({
        pickerSize: pickerSize,
        selectedColor: selectedColor,
        indicatorColor: indicatorColor,
        oldColor: oldColor,
        angle: angle,
        isRTL: this._isRTL
      });

      var SliderComp = this._getSlider();

      return _react["default"].createElement(_reactNative.View, {
        style: style
      }, _react["default"].createElement(_reactNative.View, {
        onLayout: this._onLayout,
        ref: this.pickerContainer,
        style: styles.pickerContainer
      }, !pickerSize ? null : _react["default"].createElement(_reactNative.View, null, _react["default"].createElement(_reactNative.View, _extends({}, this._pickerResponder.panHandlers, {
        style: [styles.picker, computed.picker],
        collapsable: false
      }), _react["default"].createElement(_reactNative.Image, {
        source: require('./resources/color-circle.png'),
        resizeMode: "contain",
        style: [styles.pickerImage]
      }), _react["default"].createElement(_reactNative.View, {
        style: [styles.pickerIndicator, computed.pickerIndicator]
      })), oldColor && _react["default"].createElement(_reactNative.TouchableOpacity, {
        style: [styles.selectedPreview, computed.selectedPreview],
        onPress: this._onColorSelected,
        activeOpacity: 0.7
      }), oldColor && _react["default"].createElement(_reactNative.TouchableOpacity, {
        style: [styles.originalPreview, computed.originalPreview],
        onPress: this._onOldColorSelected,
        activeOpacity: 0.7
      }), !oldColor && _react["default"].createElement(_reactNative.TouchableOpacity, {
        style: [styles.selectedFullPreview, computed.selectedFullPreview],
        onPress: this._onColorSelected,
        activeOpacity: 0.7
      }))), this.props.hideSliders ? null : _react["default"].createElement(_reactNative.View, null, _react["default"].createElement(SliderComp, {
        value: s,
        onValueChange: this._onSValueChange
      }), _react["default"].createElement(SliderComp, {
        value: v,
        onValueChange: this._onVValueChange
      })));
    }
  }]);

  return HoloColorPicker;
}(_react["default"].PureComponent);

exports.HoloColorPicker = HoloColorPicker;
HoloColorPicker.propTypes = {
  color: _propTypes["default"].oneOfType([_propTypes["default"].string, _propTypes["default"].shape({
    h: _propTypes["default"].number,
    s: _propTypes["default"].number,
    v: _propTypes["default"].number
  })]),
  defaultColor: _propTypes["default"].string,
  oldColor: _propTypes["default"].string,
  onColorChange: _propTypes["default"].func,
  onColorSelected: _propTypes["default"].func,
  onOldColorSelected: _propTypes["default"].func,
  hideSliders: _propTypes["default"].bool,
  sliderComponent: _propTypes["default"].elementType,
  // eslint-disable-next-line react/forbid-prop-types
  style: _propTypes["default"].any
};

var makeComputedStyles = function makeComputedStyles(_ref2) {
  var _pickerIndicator;

  var indicatorColor = _ref2.indicatorColor,
      selectedColor = _ref2.selectedColor,
      oldColor = _ref2.oldColor,
      angle = _ref2.angle,
      pickerSize = _ref2.pickerSize,
      isRTL = _ref2.isRTL;
  var summarySize = 0.5 * pickerSize;
  var indicatorPickerRatio = 42 / 510; // computed from picker image

  var indicatorSize = indicatorPickerRatio * pickerSize;
  var pickerPadding = indicatorSize / 3;
  var indicatorRadius = pickerSize / 2 - indicatorSize / 2 - pickerPadding;
  var mx = pickerSize / 2;
  var my = pickerSize / 2;
  var dx = Math.cos(angle) * indicatorRadius;
  var dy = Math.sin(angle) * indicatorRadius;
  return {
    picker: {
      padding: pickerPadding,
      width: pickerSize,
      height: pickerSize
    },
    pickerIndicator: (_pickerIndicator = {
      top: mx + dx - indicatorSize / 2
    }, _defineProperty(_pickerIndicator, isRTL ? 'right' : 'left', my + dy - indicatorSize / 2), _defineProperty(_pickerIndicator, "width", indicatorSize), _defineProperty(_pickerIndicator, "height", indicatorSize), _defineProperty(_pickerIndicator, "borderRadius", indicatorSize / 2), _defineProperty(_pickerIndicator, "backgroundColor", indicatorColor), _pickerIndicator),
    selectedPreview: {
      width: summarySize / 2,
      height: summarySize,
      top: pickerSize / 2 - summarySize / 2,
      left: Math.floor(pickerSize / 2),
      borderTopRightRadius: summarySize / 2,
      borderBottomRightRadius: summarySize / 2,
      backgroundColor: selectedColor
    },
    originalPreview: {
      width: Math.ceil(summarySize / 2),
      height: summarySize,
      top: pickerSize / 2 - summarySize / 2,
      left: pickerSize / 2 - summarySize / 2,
      borderTopLeftRadius: summarySize / 2,
      borderBottomLeftRadius: summarySize / 2,
      backgroundColor: oldColor
    },
    selectedFullPreview: {
      width: summarySize,
      height: summarySize,
      top: pickerSize / 2 - summarySize / 2,
      left: pickerSize / 2 - summarySize / 2,
      borderRadius: summarySize / 2,
      backgroundColor: selectedColor
    }
  };
};

var styles = _reactNative.StyleSheet.create({
  pickerContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center'
  },
  pickerImage: {
    flex: 1,
    width: null,
    height: null
  },
  pickerIndicator: {
    position: 'absolute',
    // Shadow only works on iOS.
    shadowColor: 'black',
    shadowOpacity: 0.3,
    shadowOffset: {
      width: 3,
      height: 3
    },
    shadowRadius: 4,
    // This will elevate the view on Android, causing shadow to be drawn.
    elevation: 5
  },
  selectedPreview: {
    position: 'absolute',
    borderLeftWidth: 0
  },
  originalPreview: {
    position: 'absolute',
    borderRightWidth: 0
  },
  selectedFullPreview: {
    position: 'absolute'
  },
  pickerAlignment: {
    alignItems: 'center'
  }
});